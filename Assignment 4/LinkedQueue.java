import exceptions.*;import java.util.ConcurrentModificationException;import java.util.Iterator;import java.util.NoSuchElementException;public class LinkedQueue<T> implements QueueADT<T>, Iterable<T>{    private int count;    private LinearNode<T> head, tail;    protected int modCount;    /**     * Creates an empty queue.     */    public LinkedQueue()    {        count = 0;        //set modCount to Zero        modCount = 0;        head = tail = null;    }    /**     * Adds the specified element to the tail of this queue.     * @param element the element to be added to the tail of the queue     */    public void enqueue(T element)    {        LinearNode<T> node = new LinearNode<T>(element);        if (isEmpty())            head = node;        else            tail.setNext(node);        tail = node;        count++;        //adjust modCount in case of Iterator        modCount++;    }    /**     * Removes the element at the head of this queue and returns a     * reference to it.      * @return the element at the head of this queue     * @throws EmptyCollectionException if the queue is empty     */    public T dequeue() throws EmptyCollectionException    {        if (isEmpty())            throw new EmptyCollectionException("queue");        T result = head.getElement();        head = head.getNext();        count--;        //adjust modCount in case of Iterator        modCount++;        if (isEmpty())            tail = null;        return result;    }    /**     * Returns a reference to the element at the head of this queue.     * The element is not removed from the queue.     * @return a reference to the first element in this queue     * @throws //EmptyCollectionsException if the queue is empty     */    public T first() throws EmptyCollectionException    {        //Again with the Checking        if (isEmpty())            throw new EmptyCollectionException("you suck");        else            return head.getElement();    }    /**     * Returns true if this queue is empty and false otherwise.      * @return true if this queue is empty      */    public boolean isEmpty()    {        //Still Awesome        return (head == null);    }     /**     * Returns the number of elements currently in this queue.     * @return the number of elements in the queue     */    public int size()    {        //Gotta Love those one liners        return count;    }    /**     * Returns a string representation of this queue.      * @return the string representation of the queue     */    public String toString()    {        String result = "";        //create temp node to serve as head        LinearNode<T> temp = new LinearNode<T>();        //make temp head        temp = head;        //iterate temp head and concatenate the result using null end as check stop        while (temp != null)        {            result += temp.getElement();            temp = temp.getNext();        }        return result;    }    //returns inner iterator class on iterator call    /*        * pre Outer class is instantiated        * post calls the constructor of the LinkedQueue inner class        * big(O) - 1        * */    public Iterator<T> iterator()    {        return new LinkedQueueIterator();    }    // inner iterator class with methods    private class LinkedQueueIterator implements Iterator<T>    {        //create variables for use        private LinearNode<T> temp;        private int itMC;        //constructor links the current outer class modcount with the iterators own modcount        // and creates a holder for the head        /*        * pre Outer class has been instantiated        * post creates a instance of the LinkedQueueIterator and sets the temp pointer at the head node and syncs the modcounts        * big(O) - 1        * */        public LinkedQueueIterator()        {            temp =  head;            itMC = modCount;        }        /*        * pre Outer and inner classes is instantiated and have a next value from current temp variable stored        * post returns true if there is a next element from temp pointer, throws an exception if not        * big(O) - 1        * */        public boolean hasNext() throws ConcurrentModificationException        {            if (itMC != modCount)                throw new ConcurrentModificationException();            return (temp!= null);            //This doesn't seem right but i can't figure out any other way to do it        }        /*        * pre Outer and inner classes is instantiated and have a next value from current temp variable stored        * post returns element from next item and iterates through to the next node or throws an exception if there is no next node.        * big(O) - 1        * */        public T next() throws ConcurrentModificationException        {            T output = temp.getElement();                if (!hasNext())                    throw new NoSuchElementException();                temp = temp.getNext();                return output;        }        /*        * pre Outer and inner classes is instantiated        * post Simply calls an Exception on any attempted remove.        * big(O) - 1        * */        public void remove() throws UnsupportedOperationException        {            throw new UnsupportedOperationException();        }    }}